// This is a Rust implementation of the matrix multiplication algorithm from the paper
// "Matrix Multiplication Using Only Addition" by D. Cussen/J. Ullman [1]. It uses actual
// multiplication in the base case but this would be swapped with something like the Russian
// Peasants algorithm if built into a real chip, for a fully addition-only algorithm
//
// [1] D. Cussen, J. Ullman. "Matrix Multiplication Using Only Addition."
//     arXiv preprint arXiv:2307.01415 (2023).
//     https://doi.org/10.48550/arXiv.2307.01415

fn main()
{
    // demo outer product
    let col     = vec![0,1,2,3,4,5];
    let row     = vec![3,1,4,1,5,9];
    let product = outer_product(&col, &row);
    println!("outer_product(col, row) = {:?}", product);

    // demo full matrix multiplication
    let a = Matrix { rows: 2, cols: 3, elems: vec![ vec![1,2,3],
                                                    vec![4,5,6] ]};
    let b = Matrix { rows: 3, cols: 2, elems: vec![ vec![7,8],
                                                    vec![9,10],
                                                    vec![11,12] ]};
    let matrix = matrix_mult(a, b);
    println!("matrix_mult(a, b) = {:?}", matrix);
}

// multiply an m-by-k matrix by a k-by-n matrix to give an m-by-n matrix
fn matrix_mult(a: Matrix<i32>,
               b: Matrix<i32>) -> Matrix<i32>
{
    assert_eq!(a.cols, b.rows);

    // transpose a to make it easier to refer to columns from it (as rows)
    let a_t = a.transpose();

    // add the k outer products together to construct the resulting matrix
    let mut result = zeros(a.rows, b.cols);
    for k in 0 .. a.cols {
        let col    : &Vec<i32>   = &a_t.elems[k];
        let row    : &Vec<i32>   = &b  .elems[k];
        let product: Matrix<i32> = outer_product(col, row);

        result += product;
    }

    result
}

// construct the m-by-n matrix generated by the outer product of an m-element column vector with
// an n-element row vector. this uses the vector-scalar multiplication algorithm from sec 2.2
fn outer_product(col: &Vec<i32>,
                 row: &Vec<i32>) -> Matrix<i32>
{
    let steps: Vec<StepState> = vec![];

    // if the col or row is all zeroes, the outer product will be a matrix of zeros
    if all_zeros(col) || all_zeros(row) {
        return zeros(col.len(), row.len())
    }

    // the top half of Figure 1: recursively drill down() to the base case,
    // remembering the transformations along the way in the steps vector
    let (last_element, mut steps) = down(row.clone(), steps);
    steps.reverse();

    // we can now reuse the information in steps for each element of the column vector.
    // in fact, since steps won't change for the rest of this outer product calculation,
    // let's rebind it as non-mutable
    let steps = steps;

    let mut rows: Vec<Vec<i32>> = vec![];

    for c in col {
        match c {
            0 => rows.push( vec![0; row.len()] ),  // multiplying by 0 makes a row of all zeros
            1 => rows.push( row.clone() ),         // multiplying by 1 leaves the row unchanged

            c => {
                // the bottom half of Figure 1: start with the element left over from the recursive down() phase,
                // multiply it by this column element c, then recursively expand it back to its full row width
                let row = up(&steps, vec![c*last_element]);
                rows.push(row);
            }
        }
    }

    Matrix {
        elems: rows,
        rows : col.len(),
        cols : row.len()
    }
}

// the top half of Figure 1. this very quickly reduces the vector down to a single element,
// while keeping track of the restructuring it does along the way, so we can carry out the
// reverse operations in the up() phase
fn down(    vector: Vec<i32>,
        mut steps : Vec<StepState>) -> (i32, Vec<StepState>)
{
    assert!(!vector.is_empty());

    if vector.len() == 1 {
        return (vector[0], steps)
    }

    // call align on each element, which shifts off the rightmost zero bits, keeping track
    // of the resulting integer (i32) and the number of zero bits shifted off (u32), then
    // use enumerate() to pair up each element with its location (usize) in the vector,
    let mut v: Vec<(usize, AlignedInt)> =
        vector.iter()
              .map(|elem| align(*elem))
              .enumerate()
              .collect();

    // the step numbers below match the paper on page 3

    // 1. Sort: sort by the element only; within an element group the order we store the
    //          pointers doesn't matter since they are all random-access writes in step 5
    v.sort_by(|(_,(e1,_)), (_,(e2,_))| e1.cmp(e2));

    // build a map from each distinct aligned int to a list of places it occurred in the vector
    // and how to reconstruct the original number from the aligned one
    let reconstruction_map: ReconstructionMap = group_indices_by_elem(v);

    // 2. Differences: build the differences vector D
    let elems = reconstruction_map.iter().map(|(elem,_)| *elem);
    let mut diffs: Vec<i32> = take_diffs(elems).collect();

    let has_zeros = diffs[0] == 0;
    if has_zeros {
        diffs.remove(0);
    }

    steps.push(StepState {
                   len: vector.len(),
                   has_zeros,
                   reconstruction_map
               });

    down(diffs, steps)
}

fn up(    steps: &[StepState],
      mut vec  : Vec<i32>) -> Vec<i32>
{
    if steps.is_empty() {
        return vec
    }

    // 4. Accumulate: build the vector S' in place
    accumulate(&mut vec);

    if steps[0].has_zeros {
        vec.insert(0, 0);
    }

    // 5. Follow Pointers: populate the final, scaled vector V' from elements of S'
    //    situating and unshifting them according to the reconstruction map we built
    let mut scaled: Vec<i32> = vec![ 0; steps[0].len ];

    for (j, (_, rs)) in steps[0].reconstruction_map.iter().enumerate() {
        for &(i, (shift, is_negative)) in rs {            
            scaled[i] = vec[j] << shift;

            if is_negative {
                scaled[i] *= -1;
            }
        }
    }

    // recurse with the next step and the vector transformed up to this point
    up(&steps[1..], scaled)
}

// map from the distinct integers produced by the align() call to their locations in the vector
// and how to reconstruct the original integers
type ReconstructionMap = Vec<(i32, Vec<WhereAndHow>)>;

// after processing, the align() function leaves a non-negative odd number (all twos were divided out)
// paired with the number of right shifts and the +/- sign, used later to build the scaled number
type AlignedInt   = (i32  , ShiftAndSign);
type WhereAndHow  = (usize, ShiftAndSign);
type ShiftAndSign = (u32, bool);

// each call to down() except the final one generates a StepState record to track what it did
struct StepState
{
    len      : usize, // length of the vector at the start of the step
    has_zeros: bool,  // if there are zeros in the original row, this will be true for the first step

    // map to build the scaled numbers from operations done to align the original ones
    reconstruction_map: ReconstructionMap 
}

// shift off the rightmost zeros and remember how many there were, and remember if it was a negative number
// https://chat.openai.com/share/a4c49643-8b14-44bb-a8e6-3b81bfe10e0c
fn align(elem: i32) -> AlignedInt {
    if elem == 0 {
        (elem, (0, false))
    } else {
        let shifts      = elem.trailing_zeros();
        let is_negative = elem < 0;

        (elem.abs() >> shifts, (shifts, is_negative))
    }
}

// https://chat.openai.com/share/794ee6d1-868c-4417-bb31-c9bce2907273
fn group_indices_by_elem(indexed: Vec<(usize,AlignedInt)>) -> ReconstructionMap
{
    let mut result: Vec<(i32,Vec<WhereAndHow>)> = vec![];
    for (i, (elem,(shift,is_negative))) in indexed {
        match result.last_mut() {
            Some((el, is)) if *el == elem => is.push((i,(shift,is_negative))),
            _                             => result.push((elem, vec![(i,(shift,is_negative))])),
        }
    }
    result
}

// do a scanl1 (+) in-place mutably
fn accumulate(vec: &mut Vec<i32>) {
    for i in 1 .. vec.len() {
        vec[i] += vec[i-1];
    }
}

// true if all elements in the slice are equal to 0
fn all_zeros(nums: &[i32]) -> bool {
    nums.iter().all(|n| *n == 0)
}


/* TakeDiffs iterator */

// wrap an iterator of integers and return the first one as-is, then differences
// between the subsequent pairs of integers
struct TakeDiffs<I: Iterator<Item=i32>> {
    iter    : I,           // the underlying iterator of i32s
    previous: Option<i32>, // remember the last number we saw
}

impl<I> Iterator for TakeDiffs<I>
where
    I: Iterator<Item=i32>
{
    type Item = i32;

    fn next(&mut self) -> Option<i32> {
        match self.iter.next() {
            Some(int) => {
                match self.previous {
                    Some(prev) => { self.previous = Some(int); Some(int - prev) },
                    None       => { self.previous = Some(int); Some(int)        }
                }
            },
            None => None
        }
    }
}

fn take_diffs<I>(iter: I) -> TakeDiffs<I>
where
    I: Iterator<Item=i32>
{
    TakeDiffs {
        iter,
        previous: None
    }
}


/* m-by-n Matrices */

#[derive(Debug)]
struct Matrix<T> {
    elems: Vec<Vec<T>>,
    rows : usize,
    cols : usize,
}

// chatgpt 4.0
// this lets us compare two matrices with == for unit tests
impl<T: PartialEq> PartialEq for Matrix<T> {
    fn eq(&self, other: &Self) -> bool {
        if self.rows != other.rows || self.cols != other.cols {
            return false;
        }

        for i in 0..self.rows {
        for j in 0..self.cols {
            if self.elems[i][j] != other.elems[i][j] {
                return false;
            }
        }}

        true
    }
}

// this lets us use += in the line "result += product" to accumulate the outer products
impl AddAssign for Matrix<i32> {
    fn add_assign(&mut self, rhs: Self) {
        assert_eq!(self.rows, rhs.rows);
        assert_eq!(self.cols, rhs.cols);

        for i in 0..self.rows {
        for j in 0..self.cols {
            self.elems[i][j] += rhs.elems[i][j];
        }}
    }
}

// matrix transposition from chatgpt 4.0
impl<T: Copy + Default> Matrix<T> {
    fn transpose(&self) -> Self {
        let mut result = Matrix {
            elems: vec![vec![T::default(); self.rows]; self.cols],
            rows : self.cols,
            cols : self.rows,
        };

        for i in 0..self.rows {
        for j in 0..self.cols {
            result.elems[j][i] = self.elems[i][j];
        }}

        result
    }
}

// construct a rows-by-cols matrix with all zeros
fn zeros(rows: usize,
         cols: usize) -> Matrix<i32>
{
    Matrix {
        elems: vec![ vec![0; cols]; rows ],
        rows,
        cols
    }
}


/* Imports */

use std::ops::AddAssign;


/* Tests */

#[cfg(test)]
mod tests {
    use super::{align, group_indices_by_elem, take_diffs, outer_product, matrix_mult, Matrix};

    #[test]
    fn test_group() {
        assert_eq!(vec![(1, vec![(1,(0,false)),(3,(0,true))]),
                        (3, vec![(0,(0,false))]),
                        (4, vec![(2,(0,false))]),
                        (5, vec![(4,(0,false))]),
                        (9, vec![(5,(0,false))]),],
                    group_indices_by_elem(vec![(1,(1,(0,false))), (3,(1,(0,true))), (0,(3,(0,false))), (2,(4,(0,false))), (4,(5,(0,false))), (5,(9,(0,false)))]));
    }

    #[test]
    fn test_diff_vec_normal() {
        let v = vec![1, 2, 4, 7, 11, 16];
        let diff: Vec<i32> = take_diffs(v.into_iter()).collect();
        assert_eq!(diff, vec![1,1,2,3,4,5]);
    }

    #[test]
    fn test_diff_vec_empty() {
        let v: Vec<i32> = Vec::new();
        let diff: Vec<i32> = take_diffs(v.into_iter()).collect();
        assert_eq!(diff, Vec::new());
    }

    #[test]
    fn test_diff_vec_single_element() {
        let v = vec![10];
        let diff: Vec<i32> = take_diffs(v.into_iter()).collect();
        assert_eq!(diff, vec![10]);
    }

    #[test]
    fn test_diff_vec_negatives() {
        let v = vec![5, -3, -8, 1];
        let diff: Vec<i32> = take_diffs(v.into_iter()).collect();
        assert_eq!(diff, vec![5,-8,-5,9]);
    }

    /* align(), three tests from chatgpt 4.0 */
    #[test]
    fn test_align_zero() {
        let (aligned_elem, (shifts, is_negative)) = align(0);
        assert_eq!(aligned_elem, 0);
        assert_eq!(shifts, 0);
        assert_eq!(is_negative, false);
    }

    #[test]
    fn test_align_no_trailing_zeros() {
        let (aligned_elem, (shifts, is_negative)) = align(7); // 7 is 111 in binary
        assert_eq!(aligned_elem, 7);
        assert_eq!(shifts, 0);
        assert_eq!(is_negative, false);
    }

    #[test]
    fn test_align_trailing_zeros() {
        let (aligned_elem, (shifts, is_negative)) = align(16); // 16 is 10000 in binary
        assert_eq!(aligned_elem, 1);
        assert_eq!(shifts, 4);
        assert_eq!(is_negative, false);
    }

    #[test]
    fn test_align_trailing_zeros_negative() {
        let (aligned_elem, (shifts, is_negative)) = align(-16); // 16 is 10000 in binary
        assert_eq!(aligned_elem, 1);
        assert_eq!(shifts, 4);
        assert_eq!(is_negative, true);
    }

    #[test]
    fn test_outer_product_zero_one_scalars() {
        let col = vec![0,1,2];
        let row = vec![0,1,2,3];

        assert_eq!(vec![ vec![0,0,0,0],
                         vec![0,1,2,3],
                         vec![0,2,4,6] ], outer_product(&col, &row).elems);
    }

    #[test]
    fn test_outer_product_zero_row() {
        let col = vec![0,1];
        let row = vec![0,0,0,0];

        assert_eq!(vec![ vec![0,0,0,0],
                         vec![0,0,0,0] ], outer_product(&col, &row).elems);
    }

    #[test]
    fn test_outer_product_one_non_zero() {
        let col = vec![0,1];
        let row = vec![0,0,2,0];

        assert_eq!(vec![ vec![0,0,0,0],
                         vec![0,0,2,0] ], outer_product(&col, &row).elems);
    }

    // chatgpt 4.0
    #[test]
    fn test_outer_product_same_length() {
        let col = vec![1, 2, 3];
        let row = vec![4, 5, 6];
        let result = outer_product(&col, &row);

        assert_eq!(result.rows, 3);
        assert_eq!(result.cols, 3);

        let expected_grid = vec![
            vec![4, 5, 6],
            vec![8, 10, 12],
            vec![12, 15, 18],
        ];
        
        assert_eq!(result.elems, expected_grid);
    }

    // chatgpt 4.0
    #[test]
    fn test_matrix_mult_normal() {
        let a = Matrix {
            elems: vec![
                vec![1, 2, 3],
                vec![4, 5, 6],
            ],
            rows: 2,
            cols: 3,
        };
        let b = Matrix {
            elems: vec![
                vec![7, 8],
                vec![9, 10],
                vec![11, 12]
            ],
            rows: 3,
            cols: 2,
        };
        let result = matrix_mult(a, b);

        let expected = Matrix {
            elems: vec![
                //vec![58, 64],     [jrh] i'm surprised chatgpt got these numbers right;
                //vec![139, 154],         they probably weren't actually calculated

                // [jrh] expand to see the calculations
                vec![1*7 + 2*9 + 3*11,  1*8 + 2*10 + 3*12],
                vec![4*7 + 5*9 + 6*11,  4*8 + 5*10 + 6*12],
            ],
            rows: 2,
            cols: 2,
        };

        assert_eq!(result, expected);
    }

    #[test]
    fn test_matrix_mult_with_negative_values() {
        let a        = Matrix {rows: 2, cols: 2, elems: vec![ vec![1, -2],
                                                              vec![3,  4] ]};
        let b        = Matrix {rows: 2, cols: 2, elems: vec![ vec![-2, 0],
                                                              vec![ 1,-3] ]};
        let expected = Matrix {rows: 2, cols: 2, elems: vec![ vec![-4, 6],
                                                              vec![-2,-12] ]};

        let result = matrix_mult(a, b);
        assert_eq!(result, expected);
    }
}
